#!/bin/bash

# Configuration
DEFAULT_ARCH="x86_64"
DEFAULT_IMAGE_SIZE="15G"
DEFAULT_NBD_DEVICE="/dev/nbd1"
DEFAULT_USER="test"
DEFAULT_PASSWORD="a"  # In production, use something more secure

# Paths
SCRIPT_DIR=$(dirname "$(realpath "$0")")
BLACKARCH_DIR="${SCRIPT_DIR}/.."
CHROOT_DIR="${HOME}/alt/blackarch"
IMAGE_DIR="${HOME}/alt/blackarch"

# Packages
BASE_PACKAGES=(base base-devel namcap zsh tmux sudo vim parallel moreutils)

# Global variables
declare -a mounts=()
arch="${DEFAULT_ARCH}"
nbd="${DEFAULT_NBD_DEVICE}"
image_path=""

# Helper functions
die() {
    echo >&2 "ERROR: $*"
    exit 1
}

check_root() {
    [[ $UID -eq 0 ]] || die "This script must be run as root"
}

validate_arch() {
    case "$1" in
        i686|x86_64) return 0 ;;
        *) die "Invalid architecture: $1. Supported: i686, x86_64" ;;
    esac
}

check_nbd_available() {
    if ! modprobe nbd max_part=63 >/dev/null 2>&1; then
        die "Failed to load nbd module"
    fi
}

is_mounted() {
    mountpoint -q "$1"
}

clear_mounts() {
    for (( idx=${#mounts[@]}-1 ; idx>=0 ; idx-- )) ; do
        local mount="${mounts[idx]}"
        echo "Unmounting $mount..."
        if is_mounted "$mount"; then
            umount -R "$mount" || die "Failed to unmount $mount"
        fi
        rmdir "$mount" 2>/dev/null
    done
    mounts=()

    if [[ -e "$nbd" ]]; then
        echo "Disconnecting NBD device..."
        qemu-nbd -d "$nbd" >/dev/null 2>&1
    fi
}

track_mount() {
    local target="$2"
    
    if is_mounted "$target"; then
        die "$target is already a mountpoint"
    fi

    mkdir -p "$target" || die "Failed to create mountpoint $target"
    mount "$@" || die "Failed to mount $*"

    mounts=("$target" "${mounts[@]}")
}

connect_nbd() {
    local image="$1"
    check_nbd_available
    
    if [[ -e "${nbd}p1" ]]; then
        die "NBD device ${nbd} is already in use"
    fi

    qemu-nbd -f qcow2 -c "$nbd" "$image" || die "Failed to connect NBD device"
}

setup_base_system() {
    local chroot="$1"
    local arch="$2"

    case "$arch" in
        x86_64)
            echo "Setting up x86_64 system..."
            pacstrap -d "$chroot" "${BASE_PACKAGES[@]}" || die "Pacstrap failed"
            
            # Enable multilib
            echo "Enabling multilib..."
            cat >> "$chroot/etc/pacman.conf" <<-EOF
			[multilib]
			Include = /etc/pacman.d/mirrorlist
			EOF
            ;;
            
        i686)
            echo "Setting up i686 system..."
            # Create custom pacman.conf for i686
            sed -e 's/\$arch/i686/g' /etc/pacman.d/mirrorlist > "$chroot/mirrorlist" ||
                die "Failed to create i686 mirrorlist"
                
            sed -e "s|/etc/pacman.d/mirrorlist|$chroot/mirrorlist|g" \
                -e '/Architecture/s|auto|i686|' \
                -e '/\[multilib\]/,/Include/d' \
                /etc/pacman.conf > "$chroot/pacman.conf" ||
                die "Failed to create i686 pacman.conf"

            mkdir -p "$chroot"/var/{cache/pacman/pkg,lib/pacman} ||
                die "Failed to create pacman directories"

            pacman --root "$chroot" \
                   --cachedir "$chroot/var/cache/pacman/pkg" \
                   --noconfirm \
                   --config "$chroot/pacman.conf" \
                   -Sy "${BASE_PACKAGES[@]}" || die "Package installation failed"
            ;;
    esac

    # Initialize pacman keyring
    echo "Initializing pacman keyring..."
    arch-chroot "$chroot" pacman-key --init || die "Pacman-key init failed"
    arch-chroot "$chroot" pacman-key --populate archlinux || die "Pacman-key populate failed"

    # Copy mirrorlist
    echo "Configuring mirrors..."
    cp -f /etc/pacman.d/mirrorlist "$chroot/etc/pacman.d/mirrorlist" ||
        die "Failed to copy mirrorlist"

    # Setup user
    echo "Configuring user account..."
    arch-chroot "$chroot" groupadd "$DEFAULT_USER" ||
        die "Failed to create group $DEFAULT_USER"
    arch-chroot "$chroot" useradd -s /bin/zsh -g "$DEFAULT_USER" -m "$DEFAULT_USER" ||
        die "Failed to create user $DEFAULT_USER"
    printf '%s\n' "${DEFAULT_USER}:${DEFAULT_PASSWORD}" | arch-chroot "$chroot" chpasswd ||
        die "Failed to set password"

    # Configure sudo
    echo "Configuring sudo..."
    sed -i "/root ALL/a\\${DEFAULT_USER} ALL=NOPASSWD: ALL" "$chroot/etc/sudoers" ||
        die "Failed to modify sudoers"
}

enter_chroot() {
    local chroot="$1"
    
    echo "Entering chroot..."
    track_mount "$chroot" "$chroot" --rbind
    track_mount "$BLACKARCH_DIR" "$chroot/home/${DEFAULT_USER}/blackarch" --bind
    
    # Ensure essential directories are mounted
    for dir in proc sys dev; do
        mkdir -p "$chroot/$dir"
        track_mount --bind "/$dir" "$chroot/$dir"
    done

    arch-chroot "$chroot" su - "$DEFAULT_USER"
}

# Main operations
cmd_init() {
    echo "Creating new base image for $arch..."
    image_path="${IMAGE_DIR}.${arch}.qcow2"
    
    [[ -e "$image_path" ]] && mv -f "$image_path" "${image_path}.bak"
    
    qemu-img create -f qcow2 "$image_path" "$DEFAULT_IMAGE_SIZE" ||
        die "Failed to create disk image"
    
    connect_nbd "$image_path"
    mkfs.ext4 -F "$nbd" || die "Failed to create filesystem"
    track_mount "$nbd" "$CHROOT_DIR"
    
    setup_base_system "$CHROOT_DIR" "$arch"
    
    clear_mounts
    
    echo "Creating base snapshot..."
    qemu-img snapshot -c base "$image_path" ||
        die "Failed to create base snapshot"
    
    echo "Base image created successfully at $image_path"
}

cmd_snaps() {
    image_path="${IMAGE_DIR}.${arch}.qcow2"
    [[ -f "$image_path" ]] || die "Image file not found: $image_path"
    
    echo "Snapshots for $image_path:"
    qemu-img snapshot -l "$image_path" || die "Failed to list snapshots"
}

cmd_clean() {
    image_path="${IMAGE_DIR}.${arch}.qcow2"
    [[ -f "$image_path" ]] || die "Image file not found: $image_path"
    
    echo "Reverting to base snapshot..."
    qemu-img snapshot -a base "$image_path" ||
        die "Failed to revert to base snapshot"
    
    echo "Cleaning snapshots..."
    qemu-img snapshot -l "$image_path" | awk 'NR>2 {print $2}' | grep -v '^base$' |
    while read -r snap; do
        echo "Deleting snapshot $snap..."
        qemu-img snapshot -d "$snap" "$image_path" ||
            die "Failed to delete snapshot $snap"
    done
    
    echo "Snapshots cleaned successfully"
}

cmd_revert() {
    image_path="${IMAGE_DIR}.${arch}.qcow2"
    [[ -f "$image_path" ]] || die "Image file not found: $image_path"
    
    echo "Reverting to base snapshot..."
    qemu-img snapshot -a base "$image_path" ||
        die "Failed to revert to base snapshot"
    echo "Reverted successfully"
}

cmd_enter() {
    image_path="${IMAGE_DIR}.${arch}.qcow2"
    [[ -f "$image_path" ]] || die "Image file not found: $image_path"
    
    connect_nbd "$image_path"
    track_mount "$nbd" "$CHROOT_DIR"
    
    enter_chroot "$CHROOT_DIR"
    
    clear_mounts
    
    local snap_name="build_$(date +%Y%m%d_%H%M%S)"
    echo "Creating snapshot $snap_name..."
    qemu-img snapshot -c "$snap_name" "$image_path" ||
        echo "Warning: Failed to create snapshot" >&2
}

# Main execution
main() {
    check_root
    trap clear_mounts EXIT

    # Parse arguments
    while (( $# )); do
        case "$1" in
            -a|--arch)
                validate_arch "$2"
                arch="$2"
                shift 2
                ;;
            init)
                shift
                cmd_init
                ;;
            snaps)
                shift
                cmd_snaps
                ;;
            clean)
                shift
                cmd_clean
                ;;
            revert)
                shift
                cmd_revert
                ;;
            enter)
                shift
                cmd_enter
                ;;
            *)
                die "Invalid command: $1\nUsage: $0 [--arch i686|x86_64] {init|snaps|clean|revert|enter}"
                ;;
        esac
    done
}

[[ "$0" == "$BASH_SOURCE" ]] && main "$@"
