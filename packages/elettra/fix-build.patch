--- a/CMakeLists.txt	2025-12-12 20:15:23.296292075 +0100
+++ b/CMakeLists.txt	2025-12-12 20:14:54.082456994 +0100
@@ -1,3 +1,4 @@
+cmake_minimum_required(VERSION 3.10)
 PROJECT (elettra C)
 ADD_EXECUTABLE(elettra elettra.c elettra_encrypt.c elettra_seek.c elettra_utils.c elettra_zlib.c elettra_check.c)
 INCLUDE (CheckLibraryExists)
--- a/elettra.c	2025-12-12 20:15:23.296292075 +0100
+++ b/elettra.c	2025-12-12 20:14:54.082456994 +0100
@@ -122,7 +122,7 @@
 
   if ((es = malloc (sizeof (struct elettra_stream))) == NULL)
     {
-      fprintf (stderr, "unable to malloc %d bytes: %s\n",
+      fprintf (stderr, "unable to malloc %zu bytes: %s\n",
 	       sizeof (struct elettra_stream), strerror (errno));
       return errno;
     }
--- a/elettra_check.c	2025-12-12 20:15:23.296292075 +0100
+++ b/elettra_check.c	2025-12-12 20:14:54.082456994 +0100
@@ -2,6 +2,7 @@
 #include <errno.h>
 #include <string.h>
 #include <unistd.h>
+#include <stdint.h>
 #include <stdlib.h>
 #include <pwd.h>
 #include <sys/types.h>
@@ -17,7 +18,7 @@
   int random_happens;
   int block_size;
 
-  srand ((unsigned int) &random_happens + rand ());
+  srand((unsigned int)(uintptr_t)&random_happens ^ (unsigned int)rand());
   random_happens = (rand () % AVAILABLE_INITBSIZE);
   block_size = STARTBLOCKSIZE + (random_happens * STEPBLOCKSIZE);
 
--- a/elettra_encrypt.c	2025-12-12 20:15:23.296292075 +0100
+++ b/elettra_encrypt.c	2025-12-12 20:14:54.082456994 +0100
@@ -37,7 +37,12 @@
      snprintf (es->error, ELEN, "unable to open /dev/urandom: %s\n", strerror(errno));
      return -ELET_INIT_INTERNAL;
   }
-  fread(random_block, 256, 1, randfd);
+  size_t nread = fread(random_block, 1, sizeof(random_block), randfd);
+  if (nread != sizeof(random_block)) {
+    fclose(randfd);
+    snprintf(es->error, ELEN, "short read from /dev/urandom");
+    return -ELET_INIT_INTERNAL;
+  }
   fclose(randfd);
 
   gettimeofday (&randinit, NULL);
--- a/elettra_zlib.c	2025-12-12 20:15:23.296292075 +0100
+++ b/elettra_zlib.c	2025-12-12 20:14:54.082456994 +0100
@@ -36,8 +36,13 @@
   binput = fopen (es->outfname, "rb");
   comprblock = malloc (st.st_size);
 
-  fread (comprblock, st.st_size, 1, binput);
-  fclose (binput);
+  size_t nread = fread(comprblock, 1, (size_t)st.st_size, binput);
+  fclose(binput);
+
+  if (nread != (size_t)st.st_size) {
+    free(comprblock);
+    return NULL;
+  }
 
   *finlen = st.st_size;
   return comprblock;
