--- src/mutator/main.c	2025-12-17 01:11:31.187540676 +0100
+++ main.c	2025-12-17 01:17:38.443231266 +0100
@@ -17,11 +17,11 @@
 
 /*
  * <-[ Mutator v0.1 ]->
- * 
+ *
  * Autor: @AloneInTheShell
  * Mail: alone.in.the.shell@gmail.com
  *
- * Este soft ha sido creado ante la imposiblidad de encontrar un 
+ * Este soft ha sido creado ante la imposiblidad de encontrar un
  * mutador de diccionarios que se adaptara a mis necesidades, con lo
  * que posiblemente NO cumpla las tuyas ;P
  * Por defecto realiza todas las mutaciones definidas y segun las
@@ -29,7 +29,7 @@
  * Una de las principales caracteristicas frente a otros mutadores
  * de diccionarios es que aplica determinadas "mutaciones" a los
  * resultados de pruebas anteriores, permitiendo generar passwords
- * del tipo: 
+ * del tipo:
  * corporation -> C0rp0r4t10n_2012
  * Lo cual no he encontrado en ningun otro programa del estilo.
  *
@@ -55,7 +55,9 @@
 
 #include "main.h"
 
-int 
+struct s_opts options;
+
+int
 main (int argc, char ** argv)
 {
     char output[WORDSIZE];
@@ -108,7 +110,7 @@
                 options.do_adv=TRUE;
                 break;
             case 'y':
-		if(optarg){	
+		if(optarg){
 			options.has_yrange=TRUE;
 			strncpy(options.year_range, optarg, MIN(strlen(optarg),WORDSIZE));
 		} else
@@ -174,16 +176,16 @@
     word_out = list.first;
     for (j=0;j<list.count; j++){
 	list_new(&list_out);
-	list_add_item(&list_out, word_out); 
-	
+	list_add_item(&list_out, word_out);
+
 	mutator(&list_out);
 
 	word = list_out.first;
 	for (i=0;i<list_out.count;i++){
-		write_word(fdout, word);        
+		write_word(fdout, word);
 		word = word->next;
 	}
-	
+
 	total_mutations += list_out.count;
 
 	word_out = word_out->next;
@@ -199,7 +201,7 @@
     return 0;
 }
 
-void 
+void
 usage(void)
 {
     char * help="\
@@ -217,14 +219,14 @@
 \n\t-x, --specials     \tNo append specials chars\
 \n\t-s, --strings      \tNo append,prepend hardcoded strings\
 \n\n\tOne of these options -w or -f is required";
-    
+
     printf("%s %s by %s email:<%s>\n", PROGRAM, VERSION, AUTHOR, EMAIL);
     printf("%s\n\n",help);
 
     exit(-1);
 }
 
-int 
+int
 read_word(int fd, s_word * w)
 {
     char c[WORDSIZE];
@@ -237,9 +239,9 @@
     {
         i++;
         s=read(fd, &c[i],sizeof(char));
-   // }while((c[i]!='\n')&&(s!=0));    
-    }while(!isblank(c[i]) && !isspace(c[i]) && s!= -1 && i < WORDSIZE-1);    
-    
+   // }while((c[i]!='\n')&&(s!=0));
+    }while(!isblank(c[i]) && !isspace(c[i]) && s!= -1 && i < WORDSIZE-1);
+
     //Yes, I know, this is a fucking piece of shit, but enough while implement
     //a decent trim function ;P
     if (c[i]=='\r')
@@ -247,11 +249,11 @@
 
     w->word = astrdup(c);
     w->size = i;
-    
+
     return s;
 }
 
-void 
+void
 write_word(int fd, s_word * w)
 {
     int s;
